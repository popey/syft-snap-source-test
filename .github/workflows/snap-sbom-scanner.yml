name: Snap SBOM Scanner

on:
  workflow_dispatch:  # Manual trigger

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    timeout-minutes: 7
    outputs:
      snaps: ${{ steps.select-snaps.outputs.snaps }}
      matrix-length: ${{ steps.select-snaps.outputs.matrix-length }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Restore cache
      uses: actions/cache/restore@v3
      with:
        path: |
          cache/finished.txt
          cache/failed.txt
        key: snap-scan-cache-v1
        restore-keys: |
          snap-scan-cache-
    
    - name: Create cache directory
      run: mkdir -p cache
    
    - name: Select snaps to process
      id: select-snaps
      run: |
        # Simply take the first 20 lines from names.txt
        # (since processed ones will be removed via PR)
        head -n 20 names.txt > snaps_to_process.txt
        
        # Convert to JSON array for matrix
        snaps_json=$(jq -R -s -c 'split("\n")[:-1]' snaps_to_process.txt)
        matrix_length=$(echo "$snaps_json" | jq 'length')
        
        echo "snaps=$snaps_json" >> $GITHUB_OUTPUT
        echo "matrix-length=$matrix_length" >> $GITHUB_OUTPUT
        
        echo "Snaps to process:"
        cat snaps_to_process.txt
        echo "Matrix JSON: $snaps_json"
        echo "Matrix length: $matrix_length"
        
        # Debug info
        echo "Debug info:"
        echo "Total snaps in names.txt: $(wc -l < names.txt)"
        if [ -f cache/finished.txt ]; then
          echo "Total finished (cache): $(wc -l < cache/finished.txt)"
        fi
        if [ -f cache/failed.txt ]; then
          echo "Total failed (cache): $(wc -l < cache/failed.txt)"
        fi

  scan-snaps:
    runs-on: ubuntu-latest
    timeout-minutes: 7
    needs: prepare
    if: needs.prepare.outputs.matrix-length > 0
    strategy:
      matrix:
        snap: ${{ fromJson(needs.prepare.outputs.snaps) }}
      fail-fast: false  # Don't cancel other jobs if one fails
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
    
    - name: Clone and setup Syft
      run: |
        git clone https://github.com/anchore/syft /tmp/syft
        cd /tmp/syft
        git checkout add-snap-source
        make bootstrap
    
    - name: Create sboms directory
      run: mkdir -p sboms
    
    - name: Process snap
      id: process-snap
      run: |
        snap_name="${{ matrix.snap }}"
        echo "$(date) Processing snap: $snap_name"
        
        cd /tmp/syft
        
        # Try to generate SBOM
        if go run ./cmd/syft -v --from snap "$snap_name" -o syft-json="${GITHUB_WORKSPACE}/sboms/${snap_name}-syft.json"; then
          echo "$(date) Successfully generated SBOM for $snap_name"
          echo "success=true" >> $GITHUB_OUTPUT
          echo "snap_name=$snap_name" >> $GITHUB_OUTPUT
        else
          echo "$(date) Failed to generate SBOM for $snap_name"
          echo "success=false" >> $GITHUB_OUTPUT
          echo "snap_name=$snap_name" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Create Pull Request
      if: steps.process-snap.outputs.success == 'true'
      run: |
        snap_name="${{ matrix.snap }}"
        sbom_file="sboms/${snap_name}-syft.json"
        
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        echo "Creating PR for $snap_name"
        
        # Create a new branch for this SBOM
        branch_name="add-sbom-${snap_name}-$(date +%s)"
        git checkout -b "$branch_name"
        
        # Add the SBOM file
        git add "$sbom_file"
        git commit -m "Add SBOM for snap: $snap_name"
        
        # Push the branch
        git push origin "$branch_name"
        
        # Create pull request using GitHub CLI
        gh pr create \
          --title "Add SBOM for snap: $snap_name" \
          --body "This PR adds the SBOM (Software Bill of Materials) for the snap package: \`$snap_name\`
        
        Generated automatically by the snap SBOM scanner workflow.
        
        **Snap Name:** $snap_name  
        **SBOM File:** $sbom_file  
        **Generated:** $(date)" \
          --head "$branch_name" \
          --base main
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Upload result
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.snap }}
        path: |
          result.txt
        if-no-files-found: ignore
      if: always()
    
    - name: Save result
      if: always()
      run: |
        snap_name="${{ matrix.snap }}"
        if [ "${{ steps.process-snap.outputs.success }}" == "true" ]; then
          echo "SUCCESS:$snap_name" > result.txt
        else
          echo "FAILED:$snap_name" > result.txt
        fi

  update-cache:
    runs-on: ubuntu-latest
    needs: [prepare, scan-snaps]
    if: always() && needs.prepare.outputs.matrix-length > 0
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Restore cache
      uses: actions/cache/restore@v3
      with:
        path: |
          cache/finished.txt
          cache/failed.txt
        key: snap-scan-cache-v1
        restore-keys: |
          snap-scan-cache-
    
    - name: Create cache directory
      run: mkdir -p cache
    
    - name: Download all results
      uses: actions/download-artifact@v4
      with:
        path: results/
        pattern: result-*
    
    - name: Update cache files and collect successful snaps
      run: |
        # Initialize arrays for this run
        successful_snaps=()
        failed_snaps=()
        
        # Process all result files
        for result_dir in results/result-*/; do
          if [ -f "$result_dir/result.txt" ]; then
            result_content=$(cat "$result_dir/result.txt")
            if [[ $result_content == SUCCESS:* ]]; then
              snap_name=${result_content#SUCCESS:}
              echo "$snap_name" >> cache/finished.txt
              successful_snaps+=("$snap_name")
              echo "Added $snap_name to finished.txt"
            elif [[ $result_content == FAILED:* ]]; then
              snap_name=${result_content#FAILED:}
              echo "$snap_name" >> cache/failed.txt
              failed_snaps+=("$snap_name")
              echo "Added $snap_name to failed.txt"
            fi
          fi
        done
        
        # Remove duplicates and sort
        if [ -f cache/finished.txt ]; then
          sort -u cache/finished.txt -o cache/finished.txt
        fi
        if [ -f cache/failed.txt ]; then
          sort -u cache/failed.txt -o cache/failed.txt
        fi
        
        # Save successful snaps for PR creation
        printf '%s\n' "${successful_snaps[@]}" > successful_snaps_this_run.txt
        
        echo "Updated cache files:"
        echo "Finished count: $(wc -l < cache/finished.txt 2>/dev/null || echo 0)"
        echo "Failed count: $(wc -l < cache/failed.txt 2>/dev/null || echo 0)"
        echo "Successful this run: ${#successful_snaps[@]}"
        echo "Failed this run: ${#failed_snaps[@]}"
    
    - name: Create PR to update names.txt
      if: hashFiles('successful_snaps_this_run.txt') != ''
      run: |
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Check if we have successful snaps to remove
        if [ ! -s successful_snaps_this_run.txt ]; then
          echo "No successful snaps to remove from names.txt"
          exit 0
        fi
        
        echo "Creating PR to remove processed snaps from names.txt"
        
        # Create a new branch for updating names.txt
        branch_name="update-names-$(date +%s)"
        git checkout -b "$branch_name"
        
        # Remove successful snaps from names.txt
        cp names.txt names_backup.txt
        while IFS= read -r snap_name; do
          if [ -n "$snap_name" ]; then
            # Remove the snap from names.txt (using temporary file to avoid issues)
            grep -v "^${snap_name}$" names.txt > names_temp.txt || true
            mv names_temp.txt names.txt
            echo "Removed $snap_name from names.txt"
          fi
        done < successful_snaps_this_run.txt
        
        # Check if names.txt actually changed
        if cmp -s names.txt names_backup.txt; then
          echo "No changes to names.txt, skipping PR"
          git checkout main
          exit 0
        fi
        
        # Count how many snaps were removed
        original_count=$(wc -l < names_backup.txt)
        new_count=$(wc -l < names.txt)
        removed_count=$((original_count - new_count))
        
        # Add the updated names.txt
        git add names.txt
        git commit -m "Remove $removed_count processed snaps from names.txt
        
        Successfully processed snaps removed:
        $(cat successful_snaps_this_run.txt | sed 's/^/- /')"
        
        # Push the branch
        git push origin "$branch_name"
        
        # Create pull request using GitHub CLI
        gh pr create \
          --title "Update names.txt - Remove $removed_count processed snaps" \
          --body "This PR removes $removed_count successfully processed snaps from the names.txt file.
        
        **Snaps removed:**
        $(cat successful_snaps_this_run.txt | sed 's/^/- `/' | sed 's/$/`/')
        
        **Before:** $original_count snaps  
        **After:** $new_count snaps  
        **Removed:** $removed_count snaps
        
        Generated automatically by the snap SBOM scanner workflow." \
          --head "$branch_name" \
          --base main
        
        echo "Created PR to update names.txt (removed $removed_count snaps)"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Save cache
      uses: actions/cache/save@v3
      with:
        path: |
          cache/finished.txt
          cache/failed.txt
        key: snap-scan-cache-v1
    
    - name: Summary
      run: |
        echo "## Snap SBOM Scanner Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        success_count=0
        failed_count=0
        
        # Count results from this run
        for result_dir in results/result-*/; do
          if [ -f "$result_dir/result.txt" ]; then
            result_content=$(cat "$result_dir/result.txt")
            if [[ $result_content == SUCCESS:* ]]; then
              success_count=$((success_count + 1))
              snap_name=${result_content#SUCCESS:}
              echo "- ✅ $snap_name" >> $GITHUB_STEP_SUMMARY
            elif [[ $result_content == FAILED:* ]]; then
              failed_count=$((failed_count + 1))
              snap_name=${result_content#FAILED:}
              echo "- ❌ $snap_name" >> $GITHUB_STEP_SUMMARY
            fi
          fi
        done
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "📊 **This Run:**" >> $GITHUB_STEP_SUMMARY
        echo "- Successfully processed: $success_count snaps" >> $GITHUB_STEP_SUMMARY
        echo "- Failed: $failed_count snaps" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Count totals
        total_finished=0
        total_failed=0
        
        if [ -f cache/finished.txt ]; then
          total_finished=$(wc -l < cache/finished.txt)
        fi
        
        if [ -f cache/failed.txt ]; then
          total_failed=$(wc -l < cache/failed.txt)
        fi
        
        echo "📊 **Overall Statistics:**" >> $GITHUB_STEP_SUMMARY
        echo "- Total finished: $total_finished" >> $GITHUB_STEP_SUMMARY
        echo "- Total failed: $total_failed" >> $GITHUB_STEP_SUMMARY