name: Snap SBOM Scanner

on:
  workflow_dispatch:  # Manual trigger
  schedule:
    - cron: '*/10 * * * *'  # Every 10 minutes

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      snaps: ${{ steps.select-snaps.outputs.snaps }}
      matrix-length: ${{ steps.select-snaps.outputs.matrix-length }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Restore cache
      uses: actions/cache/restore@v3
      with:
        path: |
          cache/finished.txt
          cache/failed.txt
        key: snap-scan-cache-v1
        restore-keys: |
          snap-scan-cache-
    
    - name: Create cache directory
      run: mkdir -p cache
    
    - name: Select snaps to process
      id: select-snaps
      run: |
        # Create combined exclusion list
        exclusion_file=""
        if [ -f cache/finished.txt ] || [ -f cache/failed.txt ]; then
          cat cache/finished.txt cache/failed.txt 2>/dev/null | sort -u > combined_exclusions.txt
          exclusion_file="combined_exclusions.txt"
        fi
        
        # Find snaps that haven't been processed yet
        if [ -n "$exclusion_file" ] && [ -s "$exclusion_file" ]; then
          # Filter out already processed snaps and take first 10
          grep -v -F -f "$exclusion_file" names.txt | head -n 10 > snaps_to_process.txt || true
        else
          # No exclusions, just take first 10
          head -n 10 names.txt > snaps_to_process.txt
        fi
        
        # Convert to JSON array for matrix
        snaps_json=$(jq -R -s -c 'split("\n")[:-1]' snaps_to_process.txt)
        matrix_length=$(echo "$snaps_json" | jq 'length')
        
        echo "snaps=$snaps_json" >> $GITHUB_OUTPUT
        echo "matrix-length=$matrix_length" >> $GITHUB_OUTPUT
        
        echo "Snaps to process:"
        cat snaps_to_process.txt
        echo "Matrix JSON: $snaps_json"
        echo "Matrix length: $matrix_length"
        
        # Debug info
        echo "Debug info:"
        echo "Total snaps in names.txt: $(wc -l < names.txt)"
        if [ -f cache/finished.txt ]; then
          echo "Already finished: $(wc -l < cache/finished.txt)"
        fi
        if [ -f cache/failed.txt ]; then
          echo "Already failed: $(wc -l < cache/failed.txt)"
        fi

  scan-snaps:
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.matrix-length > 0
    strategy:
      matrix:
        snap: ${{ fromJson(needs.prepare.outputs.snaps) }}
      fail-fast: false  # Don't cancel other jobs if one fails
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
    
    - name: Clone and setup Syft
      run: |
        git clone https://github.com/anchore/syft /tmp/syft
        cd /tmp/syft
        git checkout add-snap-source
        make bootstrap
    
    - name: Create sboms directory
      run: mkdir -p sboms
    
    - name: Process snap
      id: process-snap
      run: |
        snap_name="${{ matrix.snap }}"
        echo "$(date) Processing snap: $snap_name"
        
        cd /tmp/syft
        
        # Try to generate SBOM
        if go run ./cmd/syft -v --from snap "$snap_name" -o syft-json="${GITHUB_WORKSPACE}/sboms/${snap_name}-syft.json"; then
          echo "$(date) Successfully generated SBOM for $snap_name"
          echo "success=true" >> $GITHUB_OUTPUT
          echo "snap_name=$snap_name" >> $GITHUB_OUTPUT
        else
          echo "$(date) Failed to generate SBOM for $snap_name"
          echo "success=false" >> $GITHUB_OUTPUT
          echo "snap_name=$snap_name" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Create Pull Request
      if: steps.process-snap.outputs.success == 'true'
      run: |
        snap_name="${{ matrix.snap }}"
        sbom_file="sboms/${snap_name}-syft.json"
        
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        echo "Creating PR for $snap_name"
        
        # Create a new branch for this SBOM
        branch_name="add-sbom-${snap_name}-$(date +%s)"
        git checkout -b "$branch_name"
        
        # Add the SBOM file
        git add "$sbom_file"
        git commit -m "Add SBOM for snap: $snap_name"
        
        # Push the branch
        git push origin "$branch_name"
        
        # Create pull request using GitHub CLI
        gh pr create \
          --title "Add SBOM for snap: $snap_name" \
          --body "This PR adds the SBOM (Software Bill of Materials) for the snap package: \`$snap_name\`
        
        Generated automatically by the snap SBOM scanner workflow.
        
        **Snap Name:** $snap_name  
        **SBOM File:** $sbom_file  
        **Generated:** $(date)" \
          --head "$branch_name" \
          --base main
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Upload result
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.snap }}
        path: |
          result.txt
        if-no-files-found: ignore
      if: always()
    
    - name: Save result
      if: always()
      run: |
        snap_name="${{ matrix.snap }}"
        if [ "${{ steps.process-snap.outputs.success }}" == "true" ]; then
          echo "SUCCESS:$snap_name" > result.txt
        else
          echo "FAILED:$snap_name" > result.txt
        fi

  update-cache:
    runs-on: ubuntu-latest
    needs: [prepare, scan-snaps]
    if: always() && needs.prepare.outputs.matrix-length > 0
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Restore cache
      uses: actions/cache/restore@v3
      with:
        path: |
          cache/finished.txt
          cache/failed.txt
        key: snap-scan-cache-v1
        restore-keys: |
          snap-scan-cache-
    
    - name: Create cache directory
      run: mkdir -p cache
    
    - name: Download all results
      uses: actions/download-artifact@v4
      with:
        path: results/
        pattern: result-*
    
    - name: Update cache files
      run: |
        # Process all result files
        for result_dir in results/result-*/; do
          if [ -f "$result_dir/result.txt" ]; then
            result_content=$(cat "$result_dir/result.txt")
            if [[ $result_content == SUCCESS:* ]]; then
              snap_name=${result_content#SUCCESS:}
              echo "$snap_name" >> cache/finished.txt
              echo "Added $snap_name to finished.txt"
            elif [[ $result_content == FAILED:* ]]; then
              snap_name=${result_content#FAILED:}
              echo "$snap_name" >> cache/failed.txt
              echo "Added $snap_name to failed.txt"
            fi
          fi
        done
        
        # Remove duplicates and sort
        if [ -f cache/finished.txt ]; then
          sort -u cache/finished.txt -o cache/finished.txt
        fi
        if [ -f cache/failed.txt ]; then
          sort -u cache/failed.txt -o cache/failed.txt
        fi
        
        echo "Updated cache files:"
        echo "Finished count: $(wc -l < cache/finished.txt 2>/dev/null || echo 0)"
        echo "Failed count: $(wc -l < cache/failed.txt 2>/dev/null || echo 0)"
    
    - name: Save cache
      uses: actions/cache/save@v3
      with:
        path: |
          cache/finished.txt
          cache/failed.txt
        key: snap-scan-cache-v1
    
    - name: Summary
      run: |
        echo "## Snap SBOM Scanner Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        success_count=0
        failed_count=0
        
        # Count results from this run
        for result_dir in results/result-*/; do
          if [ -f "$result_dir/result.txt" ]; then
            result_content=$(cat "$result_dir/result.txt")
            if [[ $result_content == SUCCESS:* ]]; then
              success_count=$((success_count + 1))
              snap_name=${result_content#SUCCESS:}
              echo "- âœ… $snap_name" >> $GITHUB_STEP_SUMMARY
            elif [[ $result_content == FAILED:* ]]; then
              failed_count=$((failed_count + 1))
              snap_name=${result_content#FAILED:}
              echo "- âŒ $snap_name" >> $GITHUB_STEP_SUMMARY
            fi
          fi
        done
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ“Š **This Run:**" >> $GITHUB_STEP_SUMMARY
        echo "- Successfully processed: $success_count snaps" >> $GITHUB_STEP_SUMMARY
        echo "- Failed: $failed_count snaps" >> $GITHUB_STEP_SUMMARY
        
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Count totals
        total_finished=0
        total_failed=0
        
        if [ -f cache/finished.txt ]; then
          total_finished=$(wc -l < cache/finished.txt)
        fi
        
        if [ -f cache/failed.txt ]; then
          total_failed=$(wc -l < cache/failed.txt)
        fi
        
        echo "ðŸ“Š **Overall Statistics:**" >> $GITHUB_STEP_SUMMARY
        echo "- Total finished: $total_finished" >> $GITHUB_STEP_SUMMARY
        echo "- Total failed: $total_failed" >> $GITHUB_STEP_SUMMARY